<!DOCTYPE html>

<html>
    <head>
        <title>PIDeconstructed</title>

        <link type="text/css" rel="stylesheet" href="style.css" />

        <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    </head>

    <body>
        <article>
            <section>
                <h1>PIDeconstructed</h1>
                <h2>Getting from Point A to Point B</h2>

                <p>Many mechanical component or industrial system you see today uses PID Control or some variant of it, commonly used for controlling the speed, temperature, pressure, or really anything controllable and measurable. Well, what is PID?</p>

                <p>PID Control is a feedback-loop control system that stands for <b>Proportional-Integral-Derivative Control</b> and uses the following formula:</p>

                <p class="equation">\[ CO(t) = K_{p}e(t) + K_{i}\int_0^t e(t) \,dt + K_{d}e'(t) \]</p>

                <p>If you don't have any experience with calculus, this formula might seem a bit daunting at first, but hopefully it will be easier to digest by the end of this; all you'll need is some algebra. First, before we get our hands wet with simulations, I'll have to bore you a bit with what a control system is and how it works.</p>
            </section>

            <section>
                <h3>Control System Basics</h3>

                <p>When a car wants to get to a certain speed or a furnace wants to get to the right temperature, we need a feedback loop, where the controller is constantly adjusting based on the current value. PID is one type of control system that uses a feedback loop.</p>

                <p>Any control system has two important values: the <b>setpoint (SP)</b>, which is the target valueou want to get to, and the <b>proccess variable (PV)</b>, or the current value measured by a sensor that you want to get closer to the setpoint. The difference between the setpoint and process variable is the <b>error (e)</b>. The goal of ay control system is to reduce the error ideally to 0. Because all these values may be constatly changing with time, it's usually written as a function of time instead of as a variable.</p>

                <p class="equation">\[ e(t) = SP(t) - PV(t) \]</p>

                <p>Before delving into actual PID, let's take a look at a more naive control system as a example: <b>bang-bang (BB) control</b>. In BB control, when \(PV < SP\) (the error is positive), the controller output (CO) will be set to positive 1: forward, and when \(PV > SP\) (the error is negative), the controller output will be set to -1: reverse. This means that our controller only has two discreet states (technically 3, but an error of zero is unrealistic).</p>

                <p class="equation">\[ CO(t) = \begin{cases} 
                    -C, & e(t)<0 \\ 
                    C, & e(t)>0 \\ 
                    0, & e(t)=0
                \end{cases} \, \, \, \, \text{where C is a constant} \]</p>

                <p>Let's take the example of a car, which will start 10 meters from a parking spot and will try to get as close as possible. Let's pretend that the controller can set the acceleration of the car instantaneously forward and backward up to 1 m/s<sup>2</sup>. This is a very simplistic model, but it should work for the purpose of this.</p>

                <p>Let's take a look at BB Control in action! Pay attention to the error, acceleration, and velocity, and play around with the sliders:</p>

                <figure id="BBCarSim1">
                    <div class="graphPanel">
                        <div class="carSim">
                            <img class="car" src="images/car.png" />
                            <div class="setpointLine"></div>
                        </div>
                        <div class="errorBracket"></div>
                        <p>Time: <span class="time">0.00</span> s</p>
                        <p>SP: 10.00m</p>
                        <p>PV: <span class="pv">0.00</span> m</p>
                        <p>Error: <span class="error">10.00</span> m</p>
                        <p>Acceleration: <span class="acc">0.00</span> m/s<sup>2</sup></p>
                        <p>Velocity: <span class="vel">0.00</span> m/s</p>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>Max Speed (m/s):</label>
                        <div class="inputGroup">
                            <input id="maxSpeed1" class="maxSpeedInput" type="range" min="0" max="30" step="0.01" value="20">
                            <label for="maxSpeed1">20.00</label>
                        </div>
                        <hr />
                        <label>Acceleration (m/s<sup>2</sup>):</label>
                        <div class="inputGroup">
                            <input id="acc1" class="accInput" type="range" min="0" max="20" step="0.01" value="10">
                            <label for="acc1">10.00</label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>As you can see, it's not great. After all, it's not like you start braking right when you hit the crosswalk; a good control system needs some amount of prediction. Bang-bang control tends to osscilate indefinitely. You can decrease the max speed to minimize overshoot, but then it takes much longer.</p>

                <p>Instead of this clunky animation, let's use a graph. The horizontal axis will show how much time has elapsed in seconds, vertical axis will show displacement. The blue dashed line shows the target setpoint, and the red line shows the proccess variable over time. An additional green line will show the error over time. The closer the error is to 0, the better.</p>

                <figure id="BBCarSim2">
                    <div class="graphPanel">
                        <div class="carSim">
                            <img class="car" src="images/car.png" />
                            <div class="setpointLine"></div>
                        </div>
                        <div class="errorBracket"></div>
                        <div class="graph"></div>
                        <p>Time: <span class="time">0.00</span> s</p>
                        <p>SP: 10.00m</p>
                        <p>PV: <span class="pv">0.00</span> m</p>
                        <p>Error: <span class="error">10.00</span> m</p>
                        <p>Acceleration: <span class="acc">0.00</span> m/s<sup>2</sup></p>
                        <p>Velocity: <span class="vel">0.00</span> m/s</p>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>Max Speed (m/s):</label>
                        <div class="inputGroup">
                            <input id="maxSpeed1" class="maxSpeedInput" type="range" min="0" max="30" step="0.01" value="20">
                            <label for="maxSpeed1">20.00</label>
                        </div>
                        <hr />
                        <label>Acceleration (m/s<sup>2</sup>):</label>
                        <div class="inputGroup">
                            <input id="acc1" class="accInput" type="range" min="0" max="20" step="0.01" value="10">
                            <label for="acc1">10.00</label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Often, we will want to use control block diagrams to show the mechanics of a control system. In this diagram, the control system will take the setpoint and measured process variable from the sensor and calculate an error. If the error is positive, the controller will output a positive value to the process, in this case the car's wheel motors, and accelerate it forward. Vice versa for reverse. The sensor then measures the process variable and sends it back to the control system. With this feedback loop, the control system will attempt to adjust to get PV as close to SP as possible.</p>

                <img class="diagram" src="images/bbDiagram.svg" />

                <p>As you can see, bang-bang control isn't great due to the constant oscillations. While this may be acceptable for an average waterheater or thermostat where swiftness and precision aren't the most important, more precise control systems such as PID would be better.</p>
            </section>

            <section>
                <h3>P Controller: Getting There</h3>

                <p>Let's start with a P controller. The p stands for proportional, meaning the control input will be <u>proportional</u> to the error. This means that if the error is very large, the controller output will likewise be large, and if the error is small, the output will be small. The same applies for a negative error, but it's instead a negative output.</p>

                <p>Let's put it in numerical terms. If we make the controller output equal to the error, this will achieve the desired results. However, we want to multiply the error by a constant to scale it if we want to make it faster or slower. This constant is called the <b>proportional gain</b>, symbolized by \(K_{p}\).</p>

                <p>Here is ther first part of our equation. As you can see, the controllers output (\(CO(t)\)) is directly proportional to the error.</p>

                <p class="equation">\[ CO(t) = K_{p}e(t) \]</p>

                <p>Try getting a feel for a P controller in this simulation, where we've added a bit of friction to have it represent reality just a bit more accurately. Notice how instead of having the acceleration be constant, it changes based on how close the error is to 0.</p>

                <figure id="PSim3">
                    <div class="graphPanel">
                        <div class="graph"></div>
                        <p>Time: <span class="time">0.00</span> s</p>
                        <p>SP: 10.00m</p>
                        <p>PV: <span class="pv">0.00</span> m</p>
                        <p>Error: <span class="error">10.00</span> m</p>
                        <p>Acceleration: <span class="acc">0.00</span> m/s<sup>2</sup></p>
                        <p>Velocity: <span class="vel">0.00</span> m/s</p>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>Max Speed (m/s):</label>
                        <div class="inputGroup">
                            <input id="maxSpeed3" class="maxSpeedInput" type="range" min="0" max="30" step="0.01" value="20">
                            <label for="maxSpeed3">20.00</label>
                        </div>
                        <label>Max Frictional Decceleration (m/s<sup>2</sup>):</label>
                        <div class="inputGroup">
                            <input id="maxFricDec3" class="maxFricDecInput" type="range" min="0" max="5" step="0.01" value="2.5">
                            <label for="maxFricDec3">2.50</label>
                        </div>
                        <hr />
                        <label>P-Gain (K<sub>p</sub>):</label>
                        <div class="inputGroup">
                            <input id="p3" class="pInput" type="range" min="0" max="0.25" step="0.01" value="0.10">
                            <label for="p3">0.10</label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Yay, our control system, is no longer oscillating constantly, and it's a definite improvement over Bang-bang control. However, we now have another issue: the persistent error at the end. Towards the end of the graph, you can see that the error gets close to 0 but is stuck at some value. This is called the <b>steady-state error</b>. You can hover over the line on the graph to see its precise value.</p>

                <p>But what causes steady-state error? Well, since our error is very close to 0, the controller will output a small value. In a perfect world, this would be no problem, but we have friction in our world. The output from the controller is just not enough to overcome friction and drive the error to 0. While this is definitely exxagerated in our simulation, this can be a problem in the real world where a degree of precision is needed.</p>

                <p>Not all hope is lost though as our next section on PI Controllers has the solution!</p>

                <p>First let's take a look at our trusty control block diagram. You should see that our controller just takes the error and multiplies it by the proportionality constant.</p>

                <img class="diagram" src="images/pDiagram.svg" />

                <p>Now onto the next step!</p>          
            </section>

            <section>
                <h3>PI Controller: A Little Push</h3>

                <p>Now, the integral, which is what the I in PI stands for, is a pretty complex idea if you don't know calculus, but I'll try to give a basic idea for what it is in a sort of mini calculus crash course. If you're interested, you should learn more about integrals, as this is just a short and sloppy run-down.</p>
                
                <p>Put simply, the integral is the area under the graph of a function. Integrals are often notated with a weird S-shape:</p>

                <p class="equation">\[ \int f(x) \, dx \]</p>

                <p>This may seem weird, but it's quite simple. Let's say that the following graph represents the function \(f(x)\). The integral is just the area between the curve and the x-axis. The little \(dx\) just represents that our integral is in terms of our intependent variable x, but that can be ignored.</p>

                <p>Integral image</p>

                <p>If the curve goes under the x-axis, then the integral will be negative under that portion of the graph.</p>

                <p>Negative Integral image</p>

                <p>Now this might seem like something too complicated to work out, but we can approximate the integral using something called a Riemann sum. If we filled the area with rectangles, we could find the approximate area of all the rectangles. If we half the width, that would double the amount of rectangles, but also roughly half the area. The area of each rectangle is the width multiplied by the output of the function at that x-value.</p>

                <p>Riemann Sum image</p>

                <p>Note that as we decrease the width, the approximation gets closer and closer to the real integral. This gives us a way to approximate the integral relatively efficiently.</p>

                <p>We are now ready for PI COntrol.</p>

                <p>We want to find the integral of the error function. Given how the error is a recursive function, constantly adjusting to itself in real time, we can't really find the integral analytically.</p>

                <p>This is where Riemann sums come in. No control system can reasonably iterate at every single moment; there always has to be some sort of frame rate or small tick of time where the control system waits in between iterations. We can take advantage of this to approximate an integral.</p>

                <p>Riemann pi image</p>

                <p>We'll leave those computations out for now until the last chapter and pretend that we can just find the area under the curve.</p>

                <p>For our updated PI control system, here is the equation:</p>

                <p class="equation">\[ CO(t) = K_{p}e(t) + K_{i}\int e(t) \, dt \]</p>

                <p>As you can see, we've taken the P term from our P Controller and just added an integral to the end. We also have a similar \(K_{i}\), which we multiply with the integral in order to give it more or less weight. This is called the <b>i-gain</b></p>

                <p>Now you might be thinking, how is the integral supposed to make it better? Before I answer, try fiddling around with it in a simulation. What does the integral do? What happens if you give it more or less weight?</p>

                <figure id="PISim4">
                    <div class="graphPanel">
                        <div class="graph"></div>
                        <p>Time: <span class="time">0.00</span> s</p>
                        <p>SP: 10.00m</p>
                        <p>PV: <span class="pv">0.00</span> m</p>
                        <p>Error: <span class="error">10.00</span> m</p>
                        <p>Integral: <span class="int">0.00</span></p>
                        <p>Acceleration: <span class="acc">0.00</span> m/s<sup>2</sup></p>
                        <p>Velocity: <span class="vel">0.00</span> m/s</p>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>Max Speed (m/s):</label>
                        <div class="inputGroup">
                            <input id="maxSpeed4" class="maxSpeedInput" type="range" min="0" max="30" step="0.01" value="20">
                            <label for="maxSpeed4">20.00</label>
                        </div>
                        <label>Max Frictional Decceleration (m/s<sup>2</sup>):</label>
                        <div class="inputGroup">
                            <input id="maxFricDec4" class="maxFricDecInput" type="range" min="0" max="5" step="0.01" value="2.5">
                            <label for="maxFricDec4">2.50</label>
                        </div>
                        <hr />
                        <label>P-Gain (K<sub>p</sub>):</label>
                        <div class="inputGroup">
                            <input id="p4" class="pInput" type="range" min="0" max="0.25" step="0.01" value="0.2">
                            <label for="p4">0.20</label>
                        </div>
                        <label>I-Gain (K<sub>i</sub>):</label>
                        <div class="inputGroup">
                            <input id="i4" class="iInput" type="range" min="0" max="0.05" step="0.005" value="0.01">
                            <label for="i4">0.01</label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Have an idea of what the I term does? Over time, it sums up all the errors over time. When the error is still very large, it will add a lot to the controller output, accelerating it. When the error gets closer to 0, it will still increase the integral, but just a lot less. When the error gets less than 0, the integral will begin decreasing. See in the simulation how the integral changes as the error changes.</p>

                <p>Can you see how this could get rid of our pesky steady-state error? With PI Control, the steady state error will continue to increase the area under the curve even if the error stays the same. As a result, it will gruadually drive the acceleration to overcome the friction. In a sense, the integral term is way to keep pushing the controller to adjust its value.</p>

                <p>It's a big balancing act, however. An i-gain too small could lead to the error being reduced too slowly, with a steady state error basically coming back. On the other hand, if the i-gain is too big, it could cause the PV to overshoot the SP and overshoot again when trying to adjust back, causing the system to oscillate back and forth out of control. It's crucial that you understand how the i-term works in order to find that sweet spot.</p>

                <p>We can add another element to our control block diagram, which adds the i-term to our previous p-term.</p>

                <p>PI control block diagram</p>

                <p>PI Controllers are very powerful, and in some cases enough. There are many systems that use a PI controller. But, if you want even greater precision and efficiency, look no further that the full PID Controller!</p>
            </section>
        </article>
    </body>

    <script src="sliders.js"></script>
    <script src="sim.js"></script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
</html>