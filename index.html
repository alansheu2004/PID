<!DOCTYPE html>

<html>
    <head>
        <title>PIDeconstructed</title>

        <link type="text/css" rel="stylesheet" href="style.css" />
        <link type="text/css" rel="stylesheet" href="figure.css" />
    </head>

    <body>
        <h1>
            <img id="titleImage" src="images/pidIcon.svg" />
            <br />
            PIDeconstructed
        </h1>
        <h2>Getting from Point A to Point B</h2>

        <article>
            <section>
                <p>Whether you know it or not, PID is found in the machines and processes all around you. In the motors of an electric fan or the temperature settings of an oven, chances are there is some form of PID at work. So what is PID?</p>

                <p>Formally, PID Control is a feedback-loop control system that stands for <b>Proportional-Integral-Derivative Control</b> and uses the following formula:</p>

                <p class="equation">\[ CO(t) = K_{p}e(t) + K_{i}\int_0^t e(t) \,dt + K_{d} \frac{d}{dt} e(t) \]</p>

                <p>Now back up. This formula is very confusing if you're not familiar with calculus, and even if you are, what the heck is it supposed to mean? Hopefully, you'll gain an understanding for how the formula above works and an intuition for why PID does what it does.</p>
            </section>

            <section>
                <h3>Control System Basics</h3>

                <p>Before we get into actual PID, we need to talk about what a control system even is. Whenever a machine needs to get to a certain target value, whether it be speed, pressure, or temperature, it still often have to use a control system to get there if the machine can't directly control that value.</p>

                <p>For example, let's an air tank needs to get to a certain pressure. The compressor can't just immediately go to that pressure; it can only really pump in or release air. Instead of using fancy math to decide exactly how much air to pump in to get a specific pressure, the air tank can just determine whether to pump in or release air based on the current pressure and continually adjust until it reaches that desired pressure. This is called a <b>feedback loop</b>, where the control system continually adjusts its output based on the current and target values, a pivotal part of control systems.</p>

                <p>Let's get down some terminology. The <b>setpoint (SP)</b> is just a fancy name for the target value, and the <b>proccess variable (PV)</b> is an even fancier name for the current value. The difference between the setpoint and process variable is the <b>error (e)</b>. The goal of any control system is to reduce the error to as close to 0 as possible, which would mean \( PV = SP \). Because all these values may be constatly changing over time, it's usually written as a function of time instead of as a variable.</p>

                <p>It's extremely important that you get an intuition for the error. The error will be positive if \( PV < SP \) and negative if \( PV > SP \), and the larger the difference between the two, the farther from 0 the error will be.</p>

                <p class="equation">\[ e(t) = SP(t) - PV(t) \]</p>

                <p>Before delving into actual PID, let's take a look at a simpler but less effective control system as a example: <b>bang-bang (BB) control</b>. In BB control, when the error is positive, the controller output (CO) will be set to positive constant, and when the error is negative, the controller output will be set to a negative constant. This means that our controller only has two discreet states. (Technically 3, but an error of zero can be ignored in real applications).</p>

                <p class="equation">\[ CO(t) = \begin{cases} 
                    -C, & e(t)<0 \\ 
                    C, & e(t)>0 \\ 
                    0, & e(t)=0
                \end{cases}</p>

                <p> For this article, let's use a car as our model, which will try to get to a certain position. Our car will be able to instantaneously set its acceleration, but cannot directly control its speed or position, kind of like how we apply gas or the brakes to accelerate or decelerate the car.</p>

                <p>Let's take a look at BB Control in action! You can set the setpoint with the slider under the car, and then press play to watch the car go. The bars above the car represent the direction and magnitude of the error and acceleration. The error is just the signed distance between the car and setpoint, and you should be able to see its relationship with the acceleration. Try playing around will the acceleration slider and see what happens!</p>

                <figure id="BBCarSim1">
                    <div class="graphPanel">
                        <div class="errorBar">e</div>
                        <div class="accBar">acc</div>
                        <img class="car" src="images/car.png" />
                        <input type="range" class="spSlider" min="0" max="1" step="0.01" value="0.7" />
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>Acceleration:</label>
                        <div class="inputGroup">
                            <input id="acc1" class="accInput" type="range" min="0" max="1" step="0.01" value="0.5">
                            <label for="acc1"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>As you can see, it's not great. BB Control tends to be kind of a blunt hammer, with just the 2 states for the acceleration causing the position to continually overshoot and oscillate indefinitely. Even changing the acceleration doesn't remedy the problem, as it's hard to balance the sensitivity of the system while still trying to make the car arrive quickly. As a result, bang-bang control is only used for things like thermostats, where speed and precision aren't that important, and all of the changes are slow.</p>

                <p>While the animations are nice, graphs are a great way of visualising the motion of the car. The red graph will represent the PV, and the blue graph will represent the SP.</p>

                <figure id="BBCarSim2">
                    <div class="graphPanel">
                        <div class="errorBar">e</div>
                        <div class="accBar">acc</div>
                        <img class="car" src="images/car.png" />
                        <input type="range" class="spSlider" min="0" max="1" step="0.01" value="0.7" />
                        <canvas class="graph" height="1000" width="1000">
                            Your browser does not have support for HTML5 Canvas. COnsider switching to a different browser or updating.
                        </canvas>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>Acceleration:</label>
                        <div class="inputGroup">
                            <input id="acc2" class="accInput" type="range" min="0" max="1" step="0.01" value="0.5">
                            <label for="acc2"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Often, we will want to use control block diagrams to show how a control system works. In this diagram, the control system will take the setpoint and measured process variable from the sensor and calculate an error. If the error is positive, the controller will output a positive value to the process, in this case the car's wheel motors, and accelerate it forward. Vice versa for reverse. The sensor then measures the process variable and sends it back to the control system. With this feedback loop, the control system will attempt to adjust to get PV as close to SP as possible.</p>

                <img class="diagram" src="images/bbDiagram.svg" />

                <p>As we move on to more complicated control systems, make sure you understna dhow the control loop feeds into itself, processing the error and attempting to drive it to 0.</p>
            </section>

            <!--
            <section>
                <h3>P Controller: Getting There</h3>

                <p>Let's start with just a P controller and leave out the I and D. The P stands for proportional, meaning the control input will be <u>proportional</u> to the error. This means that if the error is very large, the controller output will likewise be large, and if the error is small, the output will be small. The same applies for a negative error, but it's instead a negative output.</p>

                <p>In mathematical terms, we can set the controller output equal to the error and achieve the desired result. However, we will probably want to multiply the error by a constant to scale it if we want to make it faster or slower, adjusting it to just hte right value. This constant is called the <b>proportional gain</b>, symbolized by \(K_{p}\).</p>

                <p>Here is ther first part of our equation. As you can see, the controllers output (\(CO(t)\)) is directly proportional to the error.</p>

                <p class="equation">\[ CO(t) = K_{p}e(t) \]</p>

                <p>Try getting a feel for a P controller in this simulation, where we've added a tiny bit of friction to have it represent reality just a bit more accurately. Notice how instead of having the acceleration be constant, it changes based on how close the error is to 0. WHat happens when you increase and decrease the proportional gain?</p>

                <figure id="PSim3">
                    <div class="graphPanel">
                        <div class="graph"></div>
                        <p>Time: <span class="time">0.00</span> s</p>
                        <p>SP: 10.00m</p>
                        <p>PV: <span class="pv">0.00</span> m</p>
                        <p>Error: <span class="error">10.00</span> m</p>
                        <p>Acceleration: <span class="acc">0.00</span> m/s<sup>2</sup></p>
                        <p>Velocity: <span class="vel">0.00</span> m/s</p>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>Max Speed (m/s):</label>
                        <div class="inputGroup">
                            <input id="maxSpeed3" class="maxSpeedInput" type="range" min="0" max="10" step="0.01" value="5">
                            <label for="maxSpeed3"></label>
                        </div>
                        <label>Damping:</label>
                        <div class="inputGroup">
                            <input id="damp3" class="dampInput" type="range" min="0" max="0.1" step="0.01" value="0.03">
                            <label for="damp3"></label>
                        </div>
                        <hr />
                        <label>P-Gain (K<sub>p</sub>):</label>
                        <div class="inputGroup">
                            <input id="p3" class="pInput" type="range" min="0" max="20" step="0.01" value="10">
                            <label for="p3"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Yay, our control system, is no longer oscillating constantly, and it's a definite improvement over Bang-bang control. However, we now have another issue: the persistent error at the end. Towards the end of the graph, you can see that the error gets close to 0 but is stuck at some value. This is called the <b>steady-state error</b>. You can hover over the line on the graph to see its precise value.</p>

                <p>But what causes steady-state error? Well, since our error is very close to 0, the controller will output a small value. In a perfect world, this would be no problem, but we have friction in our world. The output from the controller is just not enough to overcome friction and drive the error to 0. While this is definitely exxagerated in our simulation, this can be a problem in the real world where a degree of precision is needed.</p>

                <p>Not all hope is lost though as our next section on PI Controllers has the solution!</p>

                <p>First let's take a look at our trusty control block diagram. You should see that our controller just takes the error and multiplies it by the proportionality constant.</p>

                <img class="diagram" src="images/pDiagram.svg" />

                <p>Now onto the next step!</p>          
            </section>

            <section>
                <h3>PI Controller: A Little Push</h3>

                <p>Now, the integral, which is what the I in PI stands for, is a pretty complex idea if you don't know calculus, but I'll try to give a basic idea for what it is in a sort of mini calculus crash course. If you're already familiar with integrals, skip <a>here</a>.</p>
                
                <p>Put simply, the integral is the area under the graph of a function. Integrals are often notated with a weird S-shape:</p>

                <p class="equation">\[ \int f(x) \, dx \]</p>

                <p>This may seem weird, but it's quite simple. Let's say that the following graph represents the function \(f(x)\). The integral is just the area between the curve and the x-axis. The little \(dx\) just represents that our integral is in terms of our intependent variable x, but that can be ignored.</p>

                <img src="images/integral.png" alt="Integral" />

                <p>If the curve goes under the x-axis, then the integral will be negative under that portion of the graph.</p>

                <img src="images/negIntegral.png" alt="Negative Integral" />

                <p>Now this might seem like something too complicated to work out, but we can approximate the integral using something called a Riemann sum. If we filled the area with rectangles, we can find the approximate area of all the rectangles. As we increase the amount of rectangles, our approximation gets better and better.</p>

                <img src="images/riemann1.png" alt="Riemann Sum Thick" />
                <img src="images/riemann2.png" alt="Riemann Sum Medium" />
                <img src="images/riemann3.png" alt="Riemann Sum Thin" />

                <p>If you're still unsure about integrals and Riemann Sums, check out this interactive Desmos model <a href="https://www.desmos.com/calculator/fzh4qds1zj" target="blank">here</a>. Come back when you get a feel for integrals.</p>

                <p>We are now ready for PI COntrol.</p>

                <p>We want to find the integral of the error function. This is where Riemann sums come in. No control system can reasonably iterate at every single moment; there always has to be some sort of frame rate or small tick of time where the control system waits in between iterations. Because these ticks are very small, we can make a very good approximation of the integral with Riemann Sums.</p>

                <p>Riemann pi image</p>

                <p>We'll leave those computations out for now until the last chapter and pretend that we can just find the area under the curve.</p>

                <p>For our updated PI control system, here is the equation:</p>

                <p class="equation">\[ CO(t) = K_{p}e(t) + K_{i}\int e(t) \, dt \]</p>

                <p>As you can see, we've taken the P term from our P Controller and just added an integral to the end. We also have a similar \(K_{i}\), which we multiply with the integral in order to give it more or less weight. This is called the <b>i-gain</b></p>

                <p>Now you might be thinking, how is the integral supposed to make it better? First, try fiddling around with it in a simulation. What does the integral do? What happens if you give it more or less weight?</p>

                <figure id="PISim4">
                    <div class="graphPanel">
                        <div class="graph"></div>
                        <p>Time: <span class="time">0.00</span> s</p>
                        <p>SP: 10.00m</p>
                        <p>PV: <span class="pv">0.00</span> m</p>
                        <p>Error: <span class="error">10.00</span> m</p>
                        <p>Integral: <span class="int">0.00</span></p>
                        <p>Acceleration: <span class="acc">0.00</span> m/s<sup>2</sup></p>
                        <p>Velocity: <span class="vel">0.00</span> m/s</p>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>Max Speed (m/s):</label>
                        <div class="inputGroup">
                            <input id="maxSpeed4" class="maxSpeedInput" type="range" min="0" max="10" step="0.01" value="5">
                            <label for="maxSpeed4"></label>
                        </div>
                        <label>Damping:</label>
                        <div class="inputGroup">
                            <input id="damp4" class="dampInput" type="range" min="0" max="0.1" step="0.01" value="0.03">
                            <label for="damp4"></label>
                        </div>
                        <hr />
                        <label>P-Gain (K<sub>p</sub>):</label>
                        <div class="inputGroup">
                            <input id="p4" class="pInput" type="range" min="0" max="20" step="0.01" value="10">
                            <label for="p4"></label>
                        </div>
                        <label>I-Gain (K<sub>i</sub>):</label>
                        <div class="inputGroup">
                            <input id="i4" class="iInput" type="range" min="0" max="0.5" step="0.01" value="0.25">
                            <label for="i4">0.1</label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Have an idea of what the I term does? Over time, it sums up all the errors over time. When the error is still very large, it will add a lot to the controller output, accelerating it. When the error gets closer to 0, it will still increase the integral, but just a lot less. When the error gets less than 0, the integral will begin decreasing. See in the simulation how the integral changes as the error changes.</p>

                <p>Can you see how this could get rid of our pesky steady-state error? With PI Control, the steady state error will continue to increase the area under the curve even if the error stays the same. As a result, it will gruadually drive the acceleration to overcome the friction. In a sense, the integral term is way to keep pushing the controller to adjust its value.</p>

                <p>It's a big balancing act, however. An i-gain too small could lead to the error being reduced too slowly, with a steady state error basically coming back. On the other hand, if the i-gain is too big, it could cause the PV to overshoot the SP and overshoot again when trying to adjust back, causing the system to oscillate back and forth out of control. Even though it's very exxagerated in this model, you can see how the i-gain still overshoots quite a bit, which is a problem with PI Controllers.</p>

                <p>We can add another element to our control block diagram, which adds the i-term to our previous p-term.</p>

                <p>PI control block diagram</p>

                <p>PI Controllers are very powerful, and in some cases enough. There are many systems that use a PI controller. But, if you want even greater precision and efficiency, look no further that the full PID Controller!</p>
            </section> -->
        </article>
    </body>

    <script src="sliders.js"></script>
    <script src="sim.js"></script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
</html>