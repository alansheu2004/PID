<!DOCTYPE html>

<html>
    <head>
        <title>PIDeconstructed</title>

        <link type="text/css" rel="stylesheet" href="style.css" />
        <link type="text/css" rel="stylesheet" href="figure.css" />
    </head>

    <body>
        <h5>by Alan Sheu</h5>
        <h1>
            <img id="titleImage" src="images/pidIcon.svg" />
            <br />
            PIDeconstructed
        </h1>
        <h2>Getting from Point A to Point B</h2>

        <article>
            <section>
                <p style="padding-top: 3vw;">Whether you know it or not, PID is found in the machines and processes all around you. In the motors of an electric fan or the temperature settings of an oven, chances are there is some form of PID at work. So what is PID?</p>

                <p>Formally, PID Control is a feedback-loop control system that stands for <b>Proportional-Integral-Derivative Control</b> and uses the following formula:</p>

                <p class="equation">\[ CO(t) = K_{p}e(t) + K_{i}\int_0^t e(T) \,dT + K_{d} e'(t) \]</p>

                <p>Now back up. This formula is very confusing if you're not familiar with calculus, and even if you are, what the heck is it supposed to mean? Hopefully, you'll gain an understanding for how the formula above works and an intuition for why PID does what it does.</p>

                <p>A quick note on prerequisites. Some knowledge on calculus would be helpful, but as I will all the calculus concepts, all you really need to have down is some algebra. There's some physics in the example, but all you really need to know is that acceleration is change in velocity. As for coding, I'll be using pseudocode, but some knowledge in any programming language is always helpful.</p>
            </section>

            <section>
                <h3>________<br/> Control System Basics</h3>

                <p>Before we get into actual PID, we need to talk about what a control system even is. Whenever a machine needs to get to a certain target value, whether it be speed, pressure, or temperature, it still often have to use a control system to get there if the machine can't directly control that value.</p>

                <p>For example, let's an air tank needs to get to a certain pressure. The compressor can't just immediately go to that pressure; it can only really pump in or release air. Instead of using fancy math to decide exactly how much air to pump in to get a specific pressure, the air tank can just determine whether to pump in or release air based on the current pressure and continually adjust until it reaches that desired pressure. This is called a <b>feedback loop</b>, where the control system determines a value to output to the <b>plant</b>, or the process that does the physical actuation, and the plant returns its current measurement back to the control system for it to determine another output.</p>

                <p>Let's get down some terminology. The <b>setpoint (SP)</b> is just a fancy name for the target value, and the <b>proccess variable (PV)</b> is an even fancier name for the current value. The difference between the setpoint and process variable is the <b>error (e)</b>. The goal of any control system is to reduce the error to as close to 0 as possible, which would mean \( PV = SP \). Because all these values may be constatly changing over time, it's usually written as a function of time instead of as a variable.</p>

                <p>It's extremely important that you get an intuition for the error. The error will be positive if \( PV < SP \) and negative if \( PV > SP \), and the larger the difference between the two, the farther from 0 the error will be.</p>

                <p class="equation">\[ e(t) = SP(t) - PV(t) \]</p>

                <p>Before delving into actual PID, let's take a look at a simpler but less effective control system as a example: <b>bang-bang (BB) control</b>. In BB control, when the error is positive, the controller output (CO) will be set to positive constant, and when the error is negative, the controller output will be set to a negative constant. This means that our controller only has two discreet states. (Technically 3, but an error of zero can be ignored in real applications).</p>

                <p class="equation">\[ CO(t) = \begin{cases} 
                    -C, & e(t)<0 \\ 
                    C, & e(t)>0 \\ 
                    0, & e(t)=0
                \end{cases} \]</p>

                <p> For this article, let's use a car as our model, which will try to get to a certain position. Our car will be able to instantaneously set its acceleration, but cannot directly control its speed or position, kind of like how we apply gas or the brakes to accelerate or decelerate the car.</p>

                <p>Let's take a look at BB Control in action! You can set the setpoint with the slider under the car, and then press play to watch the car go. The bars above the car represent the direction and magnitude of the error and acceleration. The error is just the signed distance between the car and setpoint, and you should be able to see its relationship with the acceleration. Try playing around will the acceleration slider and see what happens!</p>

                <figure id="BBSim1">
                    <div class="graphPanel">
                        <div class="errorBar">e</div>
                        <div class="accBar">acc</div>
                        <img class="car" src="images/car.png" />
                        <input type="range" class="spSlider" min="0" max="1" step="0.01" value="0.7" />
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>Acceleration:</label>
                        <div class="inputGroup">
                            <input id="acc1" class="accInput" type="range" min="0" max="1" step="0.01" value="0.5">
                            <label for="acc1"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>As you can see, it's not great. BB Control tends to be kind of a blunt hammer, with just the 2 states for the acceleration causing the position to continually overshoot and oscillate indefinitely. Even changing the acceleration doesn't remedy the problem, as it's hard to balance the sensitivity of the system while still trying to make the car arrive quickly. As a result, bang-bang control is only used for things like thermostats, where speed and precision aren't that important, and all of the changes are slow.</p>

                <p>While the animations are nice, graphs are a great way of visualising the motion of the car. The red graph will represent the PV, and the blue graph will represent the SP.</p>

                <figure id="BBSim2">
                    <div class="graphPanel">
                        <div class="errorBar">e</div>
                        <div class="accBar">acc</div>
                        <img class="car" src="images/car.png" />
                        <input type="range" class="spSlider" min="0" max="1" step="0.01" value="0.7" />
                        <canvas class="graph" height="1000" width="1000">
                            Your browser does not have support for HTML5 Canvas. Consider switching to a different browser or updating.
                        </canvas>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>Acceleration:</label>
                        <div class="inputGroup">
                            <input id="acc2" class="accInput" type="range" min="0" max="1" step="0.01" value="0.5">
                            <label for="acc2"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>With a graph, the oscillatory motion becomes much clearer and easier to quantify. As we introduce PID, pay attention to the shape of the graph.</p>

                <p>Often, we will want to use control block diagrams to show the flow of a control system. In this diagram, the control system calculates the error, and figures out whether to output a positive or negative value. After sending this value to the plant, it will spit out its PV for the controller to calculate the error all over again. </p>

                <img class="diagram" src="images/bbDiagram.svg" />

                <p>As we move on to more complicated control systems, make sure you understand how the control loop feeds into itself, continually attempting to drive the error to 0.</p>
            </section>

            <section>
                <h3>________<br/> P Controller: Getting There</h3>

                <p>Let's start with just a P controller and leave out the I and D. The P stands for proportional, meaning the control output will be <u>proportional</u> to the error. This means that if the error is very large, the controller output will likewise be large, and if the error is small, the output will be small. The same applies for a negative error, but it's instead a negative output. This should help limit the oscillation from BB control, as a smaller error would mean less of a push, right?</p>

                <p>In mathematical terms, we would set the controller output structly equal to the error. However, we will probably want to multiply the error by some constant to scale it up or down, tuning it to just the right value. After all, a car's position would be much different from a pool's water level. This constant that we multiply by is called the <b>proportional gain</b>, symbolized by \(K_{p}\).</p>

                <p>Here is the equation for a P controller. As you can see, the controllers output (\(CO(t)\)) is directly proportional to the error.</p>

                <p class="equation">\[ CO(t) = K_{p}e(t) \]</p>

                <p>Try getting a feel for a P controller in this simulation, and look out for how the error relates to the acceleration. What happens when you increase and decrease the proportional gain?</p>

                <figure id="PSim3">
                    <div class="graphPanel">
                        <div class="errorBar">e</div>
                        <div class="accBar">acc</div>
                        <img class="car" src="images/car.png" />
                        <input type="range" class="spSlider" min="0" max="1" step="0.01" value="0.7" />
                        <canvas class="graph" height="1000" width="1000">
                            Your browser does not have support for HTML5 Canvas. Consider switching to a different browser or updating.
                        </canvas>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>P-Gain (K<sub>p</sub>):</label>
                        <div class="inputGroup">
                            <input id="p3" class="pInput" type="range" min="0" max="3" step="0.01" value="1.5">
                            <label for="p3"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Eh. Not much better is it? P-Control is advantageous to BB-Control as it oscillates less frequently, making it preferrable where some stability is needed. However, it still oscillates, which is a problem for us trying to minimize ther error as quickly and efficiently as possible.</p>

                <p>Here is where we introduce <b>damping</b>, or a loss of energy over time. Almost any mechanical system will experience some sort of damping; in our example, it could be caused by air resistance or kinetic friction. Regardless, damping is a factor we can't always control (expect for in simulations). We can still use it to our advantage though, and adjust our P-Gain to match it.</p>

                <p>We'll use a pretty simple model for damping, just multiplying the velocity by a constant. A damping of 0 means that the velocity will not be changed, whereas a damping of 1 means that the velocity would always be 0. This damping tends to be close to 0 but not negligible.
                    
                <p>We will also implement a minimum acceleration. This is a small threshold that the acceleration must cross over in order to start moving. This could caused by static friction, motor imperfections, or backlash in chains somewhere. Like damping, it is often an uncontrollable factor and we have to tune our gains to overcome it.</p>

                <p>Let's look at an example! Adjust the minimum acceleration and damping sliders and see how the curve behaves. </p>

                <figure id="PSim4">
                    <div class="graphPanel">
                        <div class="errorBar">e</div>
                        <div class="accBar">acc</div>
                        <img class="car" src="images/car.png" />
                        <input type="range" class="spSlider" min="0" max="1" step="0.01" value="0.7" />
                        <canvas class="graph" height="1000" width="1000">
                            Your browser does not have support for HTML5 Canvas. Consider switching to a different browser or updating.
                        </canvas>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>P-Gain (K<sub>p</sub>):</label>
                        <div class="inputGroup">
                            <input id="p4" class="pInput" type="range" min="0" max="3" step="0.01" value="1.5">
                            <label for="p4"></label>
                        </div>
                        <hr />
                        <label>Damping (0-1):</label>
                        <div class="inputGroup">
                            <input id="damp4" class="dampInput" type="range" min="0" max="0.1" step="0.01" value="0.05">
                            <label for="damp4"></label>
                        </div>
                        <label>Min. Acceleration:</label>
                        <div class="inputGroup">
                            <input id="minAcc4" class="minAccInput" type="range" min="0" max="0.1" step="0.01" value="0.05">
                            <label for="minAcc4"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Now we're getting somewhere! As you can see damping forces can actually be helpful for us to narrow down onto one value! However, if the damping and minimum acceleration are substantial, then we might run into another problem: really slow convergence onto the setpoint and possibly a <b>steady-state error</b>, that little gap you see when everything settles down.</p>

                <p>Steady state error can be quite a nuisance where precision is needed. Since our error is very close to 0, the controller will output a very small value. In a perfect world, this would be no problem, but we have friction and backlash to get in the way in the real world. The small output from the P-controller is unable to overcome the resistive forces and we end up with slow convergence or even that steady-state error in the worst case.</p>

                <p>However, not all hope is lost! The integral part of our PID controller is designed to help.</p>

                <p>Let's take a look at our current progress through a control diagram. You should be able to trace the feedback loop. Remember, in the real world, there is only so much we can do to try to limit the resistive forces, and we have to </p>

                <img class="diagram" src="images/pDiagram.svg" />         
            </section>

            <section>
                <h3>________<br/> PI Controller: A Little Push</h3>

                <p>Now, the integral, which is what the I in PI stands for, is a pretty complex idea. If you are already familiar with calculus, feel free to skim or skip ahead. Otherwise, here's the gist.</p>
                
                <p>Put simply, the integral is the area under the graph of a function. Integrals are often notated with a weird S-shape:</p>

                <p class="equation">\[ \int_a^b f(x) \, dx \]</p>

                <p>The two little numbers are the bounds of our integral. It just means the area from x=a to x=b. Let's say that the following graph represents the function \(f(x)\). The integral is just the area between the curve and the x-axis. You can just ignore the little \(dx\) for now.</p>

                <img src="images/integral.png" alt="Integral" />

                <p>Simple right? There's one caveat. If the curve goes under the x-axis, the integral there will be negative.</p>

                <img src="images/negIntegral.png" alt="Negative Integral" />

                <p>You can think of the integral as an accumulation, a sum of all the y-values over a certain range. For now, we're going to put off actually calculuating the integral to a later section and just assume thqat we can calculate it.</p>
                
                <p> If you're still a bit confused, I would recommend checking out 3Blue1Brown and their <a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr" target="_blank">Essence of Calculus</a> series. Chapter 8 talks specifically about integrals, but the entire series is great for getting an intuition for basic calculus.</p>

                <!--<p>If you're still unsure about integrals and Riemann Sums, check out this interactive Desmos model <a href="https://www.desmos.com/calculator/fzh4qds1zj" target="blank">here</a>. Come back when you get a feel for integrals.</p>-->

                <p>We are now ready for PI COntrol. For our updated PI control system, here is the equation:</p>

                <p class="equation">\[ CO(t) = K_{p}e(t) + K_{i}\int_0^t e(T) \, dT \]</p>

                <p>Now slow down! As you can see, we've taken the P term from our P Controller and just added an integral term to the end. We also have a similar \(K_{i}\) constant, which we multiply with the integral in order to give it more or less weight. This is called the <b>i-gain</b></p>

                <p>Now you might be thinking, what is the integral supposed to do? Play around in the simulation and see if you can figure it out yourself before the explanation. Because the proportional and integral terms are separate, you can see the individual components of the total acceleration that they contribute above the car. Try seeing if you can overcome the frictional forces only adjusting the integral term.</p>

                <figure id="PISim5">
                    <div class="graphPanel">
                        <div class="errorBar">e</div>
                        <div class="accPBar">acc<sub>p</sub></div>
                        <div class="accIBar">acc<sub>i</sub></div>
                        <div class="accBar">acc<sub>total</sub></div>
                        <img class="car" src="images/car.png" />
                        <input type="range" class="spSlider" min="0" max="1" step="0.01" value="0.7" />
                        <canvas class="graph" height="1000" width="1000">
                            Your browser does not have support for HTML5 Canvas. Consider switching to a different browser or updating.
                        </canvas>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>P-Gain (K<sub>p</sub>):</label>
                        <div class="inputGroup">
                            <input id="p5" class="pInput" type="range" min="0" max="3" step="0.01" value="1.5">
                            <label for="p5"></label>
                        </div>
                        <label>I-Gain (K<sub>i</sub>):</label>
                        <div class="inputGroup">
                            <input id="i5" class="iInput" type="range" min="0" max="0.5" step="0.01" value="0.25">
                            <label for="i5"></label>
                        </div>
                        <hr />
                        <label>Damping (0-1):</label>
                        <div class="inputGroup">
                            <input id="damp5" class="dampInput" type="range" min="0" max="0.1" step="0.01" value="0.05">
                            <label for="damp5"></label>
                        </div>
                        <label>Min. Acceleration:</label>
                        <div class="inputGroup">
                            <input id="minAcc5" class="minAccInput" type="range" min="0" max="0.1" step="0.01" value="0.05">
                            <label for="minAcc5"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Have an idea of what the I term does? Over time, it sums up all the cumulative errors, and as the errors add up in the integral, it will push the error towards 0.</p>

                <p>Can you see how this could get rid of our pesky steady-state error? With PI Control, the steady state error will continue to increase the area under the curve even if the error stays the same. As a result, it will gruadually drive the acceleration to overcome friction. In a sense, the integral term is way to keep pushing the controller to adjust its value, and by the time the error is very close to 0, the integral stops changing, and the acceleration components balance out.</p>

                <p>That's why for many systems, PI controllers are enough, from temperature control to fluid flow regulation. For its simplicity, PI controllers are the default for many industrial applications.</p>

                <p>Tuning it is a big balancing act, however. An i-gain too small could lead to the error being reduced too slowly, with a steady state error basically coming back. On the other hand, if the i-gain is too big, it could spiral out of control, overshooting so much as to start oscillating or even diverge. Even though it's exxagerated in this model, you can see how the i-gain still overshoots quite a bit, which is a problem with PI Controllers. Generally, some overshoot is good in a control system as it gets to the setpoint faster and allows the system to adjust, but sometimes, speed and minimizing overshoot are of the utmost importance, and that's where the D term comes in.</p>

                <p>But first, we can add another element to our control block diagram:</p>

                <img class="diagram" src="images/piDiagram.svg" />
            </section>

            <section>
                <h3>________<br/> PID Controller: Predicting the Future</h3>

                <p>For those applications where a simple PI controller just won't cut it, here's where the Derivative "D" term decomes useful.</p>

                <p>The derivative is another one of those calculus terms, but this one is a little simpler. Graphically, it's just the slope of the tangent line at a given point on a function, denoted by \( f'(x) \). You can think of it as how the dependent variable changes as the independent variable changes. Again, 3Blue1Brown's <a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr" target="_blank">Essence of Calculus</a> series highly recommended. </p>

                <p>Here's a little Desmos interactive to get a feel for derivatives. Drag around the input point and look at how the slope, or derivative changes. Notice how the derivative is positive when f(x) is increasing and how its negative when f(x) decreases.</p>

                <iframe src="https://www.desmos.com/calculator/5q1tojvdhh?embed" width="500px" height="500px" frameborder=0></iframe>

                <p>Like before, we will add an additional derivative term to our equation: our final equation for PID! Can you guess what the derivative will do?</p>

                <p class="equation">\[ CO(t) = K_{p}e(t) + K_{i}\int_0^t e(T) \,dT + K_{d} e'(t) \]</p>

                <p>If you read the section title, you can probably tell. The derivative term is there to rein the controller back, to tell the controller to slow down before it creashes into a lamppost or something. Still not sure? Try a simulation:</p>

                <figure id="PIDSim6">
                    <div class="graphPanel">
                        <div class="errorBar">e</div>
                        <div class="accPBar">acc<sub>p</sub></div>
                        <div class="accIBar">acc<sub>i</sub></div>
                        <div class="accDBar">acc<sub>d</sub></div>
                        <div class="accBar">acc<sub>total</sub></div>
                        <img class="car" src="images/car.png" />
                        <input type="range" class="spSlider" min="0" max="1" step="0.01" value="0.7" />
                        <canvas class="graph" height="1000" width="1000">
                            Your browser does not have support for HTML5 Canvas. Consider switching to a different browser or updating.
                        </canvas>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>P-Gain (K<sub>p</sub>):</label>
                        <div class="inputGroup">
                            <input id="p6" class="pInput" type="range" min="0" max="3" step="0.01" value="1.5">
                            <label for="p6"></label>
                        </div>
                        <label>I-Gain (K<sub>i</sub>):</label>
                        <div class="inputGroup">
                            <input id="i6" class="iInput" type="range" min="0" max="0.5" step="0.01" value="0.3">
                            <label for="i6"></label>
                        </div>
                        <label>D-Gain (K<sub>i</sub>):</label>
                        <div class="inputGroup">
                            <input id="d6" class="dInput" type="range" min="0" max="1" step="0.01" value="0.5">
                            <label for="d6"></label>
                        </div>
                        <hr />
                        <label>Damping (0-1):</label>
                        <div class="inputGroup">
                            <input id="damp6" class="dampInput" type="range" min="0" max="0.1" step="0.01" value="0.05">
                            <label for="damp6"></label>
                        </div>
                        <label>Min. Acceleration:</label>
                        <div class="inputGroup">
                            <input id="minAcc6" class="minAccInput" type="range" min="0" max="0.1" step="0.01" value="0.05">
                            <label for="minAcc6"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Taking a look at the vectors, you can see that the derivative action often works against the error, which seems counterintuitive, but balancing it with the P and I terms can achieve a nice effect. As the error is decreasing, meaning the derivative is negative, the derivative term itself will be negative, effectively limiting the slope so the overshoot will not be as large while the error approaches 0. While there may be a longer response time with PID compared to PI, there is significantly more stability with a lot less oscillation.</p>

                <p>The derivative term has a fatal flaw though: <b>noise</b>. With any mechical system, there will be some random uncontrollable variations in the data whether it be from shaking, external events, or just imprecise measurements. Because the derivative term uses just the error's rate of change rather than its actual value like P or I, small changes in the measurements could be amplified by the derivative term and increase instability.</p>

                <p>To simulate noise, let's multiply the alter the PV randomly by a small amount.</p>

                <figure id="PIDSim7">
                    <div class="graphPanel">
                        <div class="errorBar">e</div>
                        <div class="accPBar">acc<sub>p</sub></div>
                        <div class="accIBar">acc<sub>i</sub></div>
                        <div class="accDBar">acc<sub>d</sub></div>
                        <div class="accBar">acc<sub>total</sub></div>
                        <img class="car" src="images/car.png" />
                        <input type="range" class="spSlider" min="0" max="1" step="0.01" value="0.7" />
                        <canvas class="graph" height="1000" width="1000">
                            Your browser does not have support for HTML5 Canvas. Consider switching to a different browser or updating.
                        </canvas>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>P-Gain (K<sub>p</sub>):</label>
                        <div class="inputGroup">
                            <input id="p7" class="pInput" type="range" min="0" max="3" step="0.01" value="1.5">
                            <label for="p7"></label>
                        </div>
                        <label>I-Gain (K<sub>i</sub>):</label>
                        <div class="inputGroup">
                            <input id="i7" class="iInput" type="range" min="0" max="0.5" step="0.01" value="0.3">
                            <label for="i7"></label>
                        </div>
                        <label>D-Gain (K<sub>i</sub>):</label>
                        <div class="inputGroup">
                            <input id="d7" class="dInput" type="range" min="0" max="1" step="0.01" value="0.5">
                            <label for="d7"></label>
                        </div>
                        <hr />
                        <label>Damping (0-1):</label>
                        <div class="inputGroup">
                            <input id="damp7" class="dampInput" type="range" min="0" max="0.1" step="0.01" value="0.05">
                            <label for="damp7"></label>
                        </div>
                        <label>Min. Acceleration:</label>
                        <div class="inputGroup">
                            <input id="minAcc7" class="minAccInput" type="range" min="0" max="0.1" step="0.01" value="0.05">
                            <label for="minAcc7"></label>
                        </div>
                        <label>Random Noise:</label>
                        <div class="inputGroup">
                            <input id="noise7" class="noiseInput" type="range" min="0" max="0.02" step="0.001" value="0.01">
                            <label for="noise7"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <p>Try turning on and off the Derivative gain. You can see that the vibration in the data is handled better with just a PI controller than with the PID controller as the D-term just seems to randomly fluctuate, creating instability. In cases where the data may vary like that, it's probably better to just use a PI controller.</p>

                <p>And that's our overview of PID! To recap, here's a little control block diagram:</p>

                <img class="diagram" src="images/pidDiagram.svg" />

                <p>But now that we've learned the theoretical bits, time to figure out how to actually implement what we've learned.</p>
            </section>

            <section>
                <h3>________<br/> Implementing PID</h3>

                <p>Knowing PID is one thing, but implementing it is just a little bit more. You know how we just assumed that we could calculate the integral and derivative terms earlier? Well, here's where that comes into play.</p>

                <p>Let's start with the integral. How do we even begin to calculate it? Well integrals are calculated with something called a Riemann Sum. Take the range where you want to integrate, and split it up into discrete chunks with a width of \( dx \). Now over each of those intervals, draw a rectangle with a width of dx and a height of f(x). The sum of each of the areas of the rectangles (of course with the ones below the x-axis being negative) approximates the integral, and as the interval is split into more pieces (and \( dx \) becomes smaller), this approximation gets better. In fact, this is the definition of an integral! In the notation, the integral sign represents a sum, adding up many values on the function and multiplying them by \( dx \) to get the area of each rectangle. That's what the notation actually represents!</p>

                <iframe src="https://www.desmos.com/calculator/jxpe0vyzpj?embed" width="500px" height="500px" frameborder=0></iframe>

                <p>Now in a calculus class, we'd try to calculate the integral or solution analytically, but let's leave the differential equation solving to the people way smarter and more qualified than me. Instead, we'll take advantage of the small time slices. When PID is actually used, the feedback loop can only cycle so fast, and each time the controller updates, we can update the integral by just adding the another small slice of area. For our purposes, there are 3 ways to do this. We'll use the Left Riemann Sums, but they're basically all about the same given small enough time steps.</p>

                <p>3 integral methods</p>

                <p>For the derivative, it's the same idea. the \( f'(x) \) notation is actually shorthand for \( \frac{df(x)}{dx} \), or the change in the function over the change in x, which should be familiar as the formula for slope. At each time step of our feedcback loop, our derivative can be calculated as the change in \( e(t) \) (current error - last error) divided by the change in time, or the time step.</p>

                <p>Let's get coding! I'll be using some pseudocode, but you can probably apply the general idea to all programming languages.</p>

                <p>First we just need to set up our variables and set up our update function that will be called in the feedback loop:</p>

                <code>
                    Kp = 1.0 <br/>
                    Ki = 0.3 <br/>
                    Kd = 0.5 <br/>
                    <br/>
                    update(sp, pv, dt) <br/>
                    &emsp; return <i>something</i>
                </code>

                <p>Each time we update, we want to calculate an error based on the setpoint and process variable. The setpoint could vary quite a bit, and the proccess variable would come from whatever plant you're using. That could be from the pressure guage on an air tank or a speedometer, anything to measure your current PV. The plant would then take whatever is returned from this function to process. As for dt, it's just the time between cycles. You could have it be set on a timer to run on a certain period or have it run as fast as possible with an internal clock.</p>

                <p>First, let's implement P:</p>

                <code>
                    Kp = 1.0 <br/>
                    Ki = 0.3 <br/>
                    Kd = 0.5 <br/><br/>

                    update(sp, pv, dt) <br/>
                    &emsp; error = sp - pv <br/><br/>

                    &emsp; pTerm = Kp * error<br/>
                    &emsp; return pTerm
                </code>

                <p>Simple. We're just taking the error and multiplying it by our proportional gain. Next, I:</p>

                <code>
                    Kp = 1.0 <br/>
                    Ki = 0.3 <br/>
                    Kd = 0.5 <br/>
                    integral = 0 <br />
                    <br/>
                    update(sp, pv, dt) <br/>
                    &emsp; error = sp - pv<br/>
                    &emsp; integral += error * dt<br/><br/>

                    &emsp; pTerm = Kp * error<br/>
                    &emsp; iTerm = Ki * integral<br/>
                    &emsp; return pTerm + iTerm<br/>
                </code>

                <p>The integral is something that is persistent throughout the PID process, so we should define it outside of the function. Each time, we add the area of a little rectangle to approximate the integral. Note that if you want to use the Forward Euler method or Trapezoidal method, you have to keep track of the last error as well, and use that to help calculate the area of the rectangles or trapezoids respectively. We will have to use the last error for the derivative anyway.</p>

                <p>And finally the derivative:</p>

                <code>
                    Kp = 1.0 <br/>
                    Ki = 0.3 <br/>
                    Kd = 0.5 <br/>
                    integral = 0 <br />
                    lastError = 0 <br />
                    <br/>
                    update(sp, pv, dt) <br/>
                    &emsp; error = sp - pv<br/>
                    &emsp; integral += error * dt<br/>
                    &emsp; derivative = (error - lastError) / dt<br/><br/>

                    &emsp; pTerm = Kp * error<br/>
                    &emsp; iTerm = Ki * integral<br/>
                    &emsp; dTerm = Kd * derivative<br/>
                    &emsp; return pTerm + iTerm + dTerm<br/>
                </code>

                <p>And that's it. Change in error over change in time. That's it for coding PID. Of course there's much more you can do such as a bias terms and feed-forward, and there may be specific tweaks in specific languages such as in object-oriented languages. I recommend doing some of your own research on PID and even take a look at some examples. It never hurts to just take a look at the work others have done!</p>

                <p>If you're interested on trying some PID programming, check out <a href="https://janismac.github.io/ControlChallenges/">JanisMac's Control Challenges</a>. See if you can implement PID and even try tuning it!</p>
            </section>

            <section style="padding-bottom: 0">
                <h3>________<br/> Tuning PID</h3>

                <p>Now we come to the crux of PID: tuning. Even if you have the most advanced control system in the world, it will amount to nothing if you don't tune it to its specific condition. For PID, you have to tune the three gains, adjusting them to suit whatever need your system requires.</p>

                <p>Because the constants of PID are not connected to any physical properties, they must be determined experimentally rather than analytically, and these values often vary wildly with different systems. There are some algorithms that take experimental data to tune optimal gains such as the Zieglerâ€“Nichols, and many softwares that can automatically find the optimal PID parameters, all of which you can find more about online. For this article, we'll just go with manual tuning. Note that this doesn't mean everything is done by hand, just the determination of the gains; almost all applications of PID are electronic, and it's very useful to use softwhere that can graph the data to analyze.</p>

                <p>Also, remember that different systems will have different needs to meet and may require different tuning methods to achieve optimal results. This will just be a very general guide (that I definitely did not steal from Wikipedia), but always use knowledge specific to whatever application and past experience as guides.</p>

                <ol>
                    <li>Set all the gains to 0 as a baseline. The plant should have no response.</li>
                    <li>Slowly increase the p-gain until the PV begins to oscillate around the setpoint in a wave. You should do this between trials, looking at the graph between each trial and not dynamically chnaging it as it runs.</li>
                    <li>Approximately cut the p-gain in half. This should lead to a decay in the amplitude.</li>
                    <li>Now slowly increase the i-gain to overcome whatever steady-state error or damping. The error should hopefully converge onto 0. Be careful, as too much i-gain can lead to overshoot and oscillation or divergence.</li>
                    <li>If needed, slowly increase the d-gain until satisfaction. Note that while this should decrease the overshoot and make it less wobbly, it could increase the response time if too high. It all depends on what you value: precision or speed.</li>
                    <li>Adjust your gains or do it over again until its as perfect as you need!</li>
                </ol>

                <p>This series of images (from Wikipedia, of course), is a demonstration of what this process might look like:</p>

                <img src="images/pidTuning.gif" alt="PID Tuning Demo" /><br />

                <table>
                    <tr>
                        <td>
                            <img src="images/varyP.jpg" alt="Varying Kp" class="gallery" />
                            <small>Varying K<sub>p</sub>, keeping K<sub>i</sub> & K<sub>d</sub> constant</small>
                        </td>
                        <td>
                            <img src="images/varyI.png" alt="Varying Ki" class="gallery" />
                            <small>Varying K<sub>i</sub>, keeping K<sub>p</sub> & K<sub>d</sub> constant</small>
                        </td>
                        <td>
                            <img src="images/varyD.png" alt="Varying Kd" class="gallery" />
                            <small>Varying K<sub>d</sub>, keeping K<sub>p</sub> & K<sub>i</sub> constant</small>
                        </td>
                    </tr>
                </table>

                <p>And remember, if there is a better way to tune for your specific application, go for that! Sometimes there are standards that you can set the gains to and then adjust from that!</p>

                <p>This article is just a basic overview of the process of PID, and I hope it sparked some interest, if not at least educated you a bit. There are always more levels to go down, more things you can refine with PID and controls systems beyond with crazy linear algebra. I encourage you to go ahead and explore for yourself if you're interested!</p>

                <p>Finally, here's one last simulation with everything I can think of:</p>

                <figure id="PIDSim8">
                    <div class="graphPanel">
                        <div class="errorBar">e</div>
                        <div class="accPBar">acc<sub>p</sub></div>
                        <div class="accIBar">acc<sub>i</sub></div>
                        <div class="accDBar">acc<sub>d</sub></div>
                        <div class="accBar">acc<sub>total</sub></div>
                        <img class="car" src="images/car.png" />
                        <input type="range" class="spSlider" min="0" max="1" step="0.01" value="0.7" />
                        <canvas class="graph" height="1000" width="1000">
                            Your browser does not have support for HTML5 Canvas. Consider switching to a different browser or updating.
                        </canvas>
                    </div>

                    <div class="optPanel">
                        <h4>Controls</h4>
                        <label>P-Gain (K<sub>p</sub>):</label>
                        <div class="inputGroup">
                            <input id="p8" class="pInput" type="range" min="0" max="3" step="0.01" value="0">
                            <label for="p8"></label>
                        </div>
                        <label>I-Gain (K<sub>i</sub>):</label>
                        <div class="inputGroup">
                            <input id="i8" class="iInput" type="range" min="0" max="1" step="0.01" value="0">
                            <label for="i8"></label>
                        </div>
                        <label>D-Gain (K<sub>i</sub>):</label>
                        <div class="inputGroup">
                            <input id="d8" class="dInput" type="range" min="0" max="1" step="0.01" value="0">
                            <label for="d8"></label>
                        </div>
                        <hr />
                        <label>Damping (0-1):</label>
                        <div class="inputGroup">
                            <input id="damp8" class="dampInput" type="range" min="0" max="1" step="0.01" value="0">
                            <label for="damp8"></label>
                        </div>
                        <label>Min. Acceleration:</label>
                        <div class="inputGroup">
                            <input id="minAcc8" class="minAccInput" type="range" min="0" max="0.1" step="0.001" value="0">
                            <label for="minAcc8"></label>
                        </div>
                        <label>Random Noise:</label>
                        <div class="inputGroup">
                            <input id="noise8" class="noiseInput" type="range" min="0" max="0.05" step="0.001" value="0">
                            <label for="noise8"></label>
                        </div>
                        <div>
                            <button class="optButton play"><img src="images/play.png" />Play</button>
                            <button class="optButton pause"><img src="images/pause.png" />Pause</button>
                            <button class="optButton reset"><img src="images/reset.png" />Reset</button>
                        </div>
                    </div>
                </figure>

                <div id="footerTransition"></div>
            </section>
        </article>

        <footer>
            <div id="coolButtons">
                <a href="https://github.com/alansheu2004"><img src="images/github.png" /></a>
            </div>
            <p>Phone: 1 (408)-218-0411</p>
            <p>Email: <a href="mailto:alansheu2004@gmail.com">alansheu2004@gmail.com</a></p>
            <p>Check out some other projects at <a href="https://alansheu2004.github.io">alansheu2004.github.io</a></p>
        </footer>
    </body>

    <script src="sliders.js"></script>
    <script src="sim.js"></script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
</html>